"""
This type stub file was generated by pyright.
"""

import io

"""Module for file-like access of blobs, usually invoked via Blob.open()."""
CHUNK_SIZE_MULTIPLE = ...
DEFAULT_CHUNK_SIZE = ...
VALID_DOWNLOAD_KWARGS = ...
VALID_UPLOAD_KWARGS = ...
class BlobReader(io.BufferedIOBase):
    """A file-like object that reads from a blob.

    :type blob: 'google.cloud.storage.blob.Blob'
    :param blob:
        The blob to download.

    :type chunk_size: long
    :param chunk_size:
        (Optional) The minimum number of bytes to read at a time. If fewer
        bytes than the chunk_size are requested, the remainder is buffered.
        The default is the chunk_size of the blob, or 40MiB.

    :type retry: google.api_core.retry.Retry or google.cloud.storage.retry.ConditionalRetryPolicy
    :param retry:
        (Optional) How to retry the RPC. A None value will disable
        retries. A google.api_core.retry.Retry value will enable retries,
        and the object will define retriable response codes and errors and
        configure backoff and timeout options.

        A google.cloud.storage.retry.ConditionalRetryPolicy value wraps a
        Retry object and activates it only if certain conditions are met.
        This class exists to provide safe defaults for RPC calls that are
        not technically safe to retry normally (due to potential data
        duplication or other side-effects) but become safe to retry if a
        condition such as if_metageneration_match is set.

        See the retry.py source code and docstrings in this package
        (google.cloud.storage.retry) for information on retry types and how
        to configure them.

        Media operations (downloads and uploads) do not support non-default
        predicates in a Retry object. The default will always be used. Other
        configuration changes for Retry objects such as delays and deadlines
        are respected.

    :param download_kwargs:
        Keyword arguments to pass to the underlying API calls.
        The following arguments are supported:

        - ``if_generation_match``
        - ``if_generation_not_match``
        - ``if_metageneration_match``
        - ``if_metageneration_not_match``
        - ``timeout``

        Note that download_kwargs are also applied to blob.reload(), if a reload
        is needed during seek().
    """
    def __init__(self, blob, chunk_size=..., retry=..., **download_kwargs) -> None:
        ...

    def read(self, size=...): # -> bytes:
        ...

    def read1(self, size=...): # -> bytes:
        ...

    def seek(self, pos, whence=...): # -> int:
        """Seek within the blob.

        This implementation of seek() uses knowledge of the blob size to
        validate that the reported position does not exceed the blob last byte.
        If the blob size is not already known it will call blob.reload().
        """
        ...

    def close(self): # -> None:
        ...

    @property
    def closed(self): # -> bool:
        ...

    def readable(self): # -> Literal[True]:
        ...

    def writable(self): # -> Literal[False]:
        ...

    def seekable(self): # -> Literal[True]:
        ...



class BlobWriter(io.BufferedIOBase):
    """A file-like object that writes to a blob.

    :type blob: 'google.cloud.storage.blob.Blob'
    :param blob:
        The blob to which to write.

    :type chunk_size: long
    :param chunk_size:
        (Optional) The maximum number of bytes to buffer before sending data
        to the server, and the size of each request when data is sent.
        Writes are implemented as a "resumable upload", so chunk_size for
        writes must be exactly a multiple of 256KiB as with other resumable
        uploads. The default is the chunk_size of the blob, or 40 MiB.

    :type text_mode: bool
    :param text_mode:
        (Deprecated) A synonym for ignore_flush. For backwards-compatibility,
        if True, sets ignore_flush to True. Use ignore_flush instead. This
        parameter will be removed in a future release.

    :type ignore_flush: bool
    :param ignore_flush:
        Makes flush() do nothing instead of raise an error. flush() without
        closing is not supported by the remote service and therefore calling it
        on this class normally results in io.UnsupportedOperation. However, that
        behavior is incompatible with some consumers and wrappers of file
        objects in Python, such as zipfile.ZipFile or io.TextIOWrapper. Setting
        ignore_flush will cause flush() to successfully do nothing, for
        compatibility with those contexts. The correct way to actually flush
        data to the remote server is to close() (using this object as a context
        manager is recommended).

    :type retry: google.api_core.retry.Retry or google.cloud.storage.retry.ConditionalRetryPolicy
    :param retry:
        (Optional) How to retry the RPC. A None value will disable
        retries. A google.api_core.retry.Retry value will enable retries,
        and the object will define retriable response codes and errors and
        configure backoff and timeout options.

        A google.cloud.storage.retry.ConditionalRetryPolicy value wraps a
        Retry object and activates it only if certain conditions are met.
        This class exists to provide safe defaults for RPC calls that are
        not technically safe to retry normally (due to potential data
        duplication or other side-effects) but become safe to retry if a
        condition such as if_metageneration_match is set.

        See the retry.py source code and docstrings in this package
        (google.cloud.storage.retry) for information on retry types and how
        to configure them.

        Media operations (downloads and uploads) do not support non-default
        predicates in a Retry object. The default will always be used. Other
        configuration changes for Retry objects such as delays and deadlines
        are respected.

    :param upload_kwargs:
        Keyword arguments to pass to the underlying API
        calls. The following arguments are supported:

        - ``if_generation_match``
        - ``if_generation_not_match``
        - ``if_metageneration_match``
        - ``if_metageneration_not_match``
        - ``timeout``
        - ``content_type``
        - ``num_retries``
        - ``predefined_acl``
        - ``checksum``
    """
    def __init__(self, blob, chunk_size=..., text_mode=..., ignore_flush=..., retry=..., **upload_kwargs) -> None:
        ...

    def write(self, b): # -> int:
        ...

    def tell(self): # -> int:
        ...

    def flush(self): # -> None:
        ...

    def close(self): # -> None:
        ...

    @property
    def closed(self): # -> bool:
        ...

    def readable(self): # -> Literal[False]:
        ...

    def writable(self): # -> Literal[True]:
        ...

    def seekable(self): # -> Literal[False]:
        ...



class SlidingBuffer:
    """A non-rewindable buffer that frees memory of chunks already consumed.

    This class is necessary because `google-resumable-media-python` expects
    `tell()` to work relative to the start of the file, not relative to a place
    in an intermediate buffer. Using this class, we present an external
    interface with consistent seek and tell behavior without having to actually
    store bytes already sent.

    Behavior of this class differs from an ordinary BytesIO buffer. `write()`
    will always append to the end of the file only and not change the seek
    position otherwise. `flush()` will delete all data already read (data to the
    left of the seek position). `tell()` will report the seek position of the
    buffer including all deleted data. Additionally the class implements
    __len__() which will report the size of the actual underlying buffer.

    This class does not attempt to implement the entire Python I/O interface.
    """
    def __init__(self) -> None:
        ...

    def write(self, b): # -> int:
        """Append to the end of the buffer without changing the position."""
        ...

    def read(self, size=...): # -> bytes:
        """Read and move the cursor."""
        ...

    def flush(self): # -> None:
        """Delete already-read data (all data to the left of the position)."""
        ...

    def tell(self): # -> int:
        """Report how many bytes have been read from the buffer in total."""
        ...

    def seek(self, pos):
        """Seek to a position (backwards only) within the internal buffer.

        This implementation of seek() verifies that the seek destination is
        contained in _buffer. It will raise ValueError if the destination byte
        has already been purged from the buffer.

        The "whence" argument is not supported in this implementation.
        """
        ...

    def __len__(self): # -> int:
        """Determine the size of the buffer by seeking to the end."""
        ...

    def close(self): # -> None:
        ...

    @property
    def closed(self): # -> bool:
        ...
