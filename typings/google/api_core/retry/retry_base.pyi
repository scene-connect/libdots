"""
This type stub file was generated by pyright.
"""

from enum import Enum
from typing import Any, Callable, Optional, TYPE_CHECKING

"""Shared classes and functions for retrying requests.

:class:`_BaseRetry` is the base class for :class:`Retry`,
:class:`AsyncRetry`, :class:`StreamingRetry`, and :class:`AsyncStreamingRetry`.
"""
if TYPE_CHECKING:
    ...
_DEFAULT_INITIAL_DELAY = ...
_DEFAULT_MAXIMUM_DELAY = ...
_DEFAULT_DELAY_MULTIPLIER = ...
_DEFAULT_DEADLINE = ...
_LOGGER = ...
def if_exception_type(*exception_types: type[Exception]) -> Callable[[Exception], bool]:
    """Creates a predicate to check if the exception is of a given type.

    Args:
        exception_types (Sequence[:func:`type`]): The exception types to check
            for.

    Returns:
        Callable[Exception]: A predicate that returns True if the provided
            exception is of the given type(s).
    """
    ...

if_transient_error = ...
def exponential_sleep_generator(initial: float, maximum: float, multiplier: float = ...): # -> Generator[float, Any, NoReturn]:
    """Generates sleep intervals based on the exponential back-off algorithm.

    This implements the `Truncated Exponential Back-off`_ algorithm.

    .. _Truncated Exponential Back-off:
        https://cloud.google.com/storage/docs/exponential-backoff

    Args:
        initial (float): The minimum amount of time to delay. This must
            be greater than 0.
        maximum (float): The maximum amount of time to delay.
        multiplier (float): The multiplier applied to the delay.

    Yields:
        float: successive sleep intervals.
    """
    ...

class RetryFailureReason(Enum):
    """
    The cause of a failed retry, used when building exceptions
    """
    TIMEOUT = ...
    NON_RETRYABLE_ERROR = ...


def build_retry_error(exc_list: list[Exception], reason: RetryFailureReason, timeout_val: float | None, **kwargs: Any) -> tuple[Exception, Exception | None]:
    """
    Default exception_factory implementation.

    Returns a RetryError if the failure is due to a timeout, otherwise
    returns the last exception encountered.

    Args:
      - exc_list: list of exceptions that occurred during the retry
      - reason: reason for the retry failure.
            Can be TIMEOUT or NON_RETRYABLE_ERROR
      - timeout_val: the original timeout value for the retry (in seconds), for use in the exception message

    Returns:
      - tuple: a tuple of the exception to be raised, and the cause exception if any
    """
    ...

class _BaseRetry:
    """
    Base class for retry configuration objects. This class is intended to capture retry
    and backoff configuration that is common to both synchronous and asynchronous retries,
    for both unary and streaming RPCs. It is not intended to be instantiated directly,
    but rather to be subclassed by the various retry configuration classes.
    """
    def __init__(self, predicate: Callable[[Exception], bool] = ..., initial: float = ..., maximum: float = ..., multiplier: float = ..., timeout: Optional[float] = ..., on_error: Optional[Callable[[Exception], Any]] = ..., **kwargs: Any) -> None:
        ...

    def __call__(self, *args, **kwargs) -> Any:
        ...

    @property
    def deadline(self) -> float | None:
        """
        DEPRECATED: use ``timeout`` instead.  Refer to the ``Retry`` class
        documentation for details.
        """
        ...

    @property
    def timeout(self) -> float | None:
        ...

    def with_deadline(self, deadline: float | None) -> Self:
        """Return a copy of this retry with the given timeout.

        DEPRECATED: use :meth:`with_timeout` instead. Refer to the ``Retry`` class
        documentation for details.

        Args:
            deadline (float|None): How long to keep retrying, in seconds. If None,
                no timeout is enforced.

        Returns:
            Retry: A new retry instance with the given timeout.
        """
        ...

    def with_timeout(self, timeout: float | None) -> Self:
        """Return a copy of this retry with the given timeout.

        Args:
            timeout (float): How long to keep retrying, in seconds. If None,
                no timeout will be enforced.

        Returns:
            Retry: A new retry instance with the given timeout.
        """
        ...

    def with_predicate(self, predicate: Callable[[Exception], bool]) -> Self:
        """Return a copy of this retry with the given predicate.

        Args:
            predicate (Callable[Exception]): A callable that should return
                ``True`` if the given exception is retryable.

        Returns:
            Retry: A new retry instance with the given predicate.
        """
        ...

    def with_delay(self, initial: Optional[float] = ..., maximum: Optional[float] = ..., multiplier: Optional[float] = ...) -> Self:
        """Return a copy of this retry with the given delay options.

        Args:
            initial (float): The minimum amount of time to delay (in seconds). This must
                be greater than 0. If None, the current value is used.
            maximum (float): The maximum amount of time to delay (in seconds). If None, the
                current value is used.
            multiplier (float): The multiplier applied to the delay. If None, the current
                value is used.

        Returns:
            Retry: A new retry instance with the given delay options.
        """
        ...

    def __str__(self) -> str:
        ...
