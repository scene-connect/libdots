"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod

""" The resource module proposes all the concepts that are related to Resource
handling. A Resource represents a special model container that can be
serialized. Many ``Resource`` can be contained in a ``ResourceSet``, and
"cross-reference" each others.
"""
global_registry = ...
global_uri_mapper = ...
global_uri_converter = ...
class ResourceSet:
    """Defines a Resource container.

    A ResourceSet can contains many Resources and has the ability to create new
    ones. It also gives a way of isolating resources from each others and to
    "localy" register metamodels.

    Resource can be created empty (using ``create_resource(...)``) or with data
    fetched from the actual resource content (using ``get_resource(...)``).

    A :py:class:`ResourceSet` contains 3 handy properties:

    * ``resources`` which is a dictonary of the ResourceSet loaded resources
      (key is the plain string URI, value: the resource).
    * ``metamodel_registry`` which is a dictonary of the ResourceSet known
      metamodels (key is the plain string metamodel URI, value: the metamodel
      ``EPackage`` root)
    * ``resource_factory`` which is a factory used by the ResourceSet to build
      the right Resource kind regarding the URI.

    .. seealso:: Resource
    """
    def __init__(self) -> None:
        ...

    def create_resource(self, uri):
        """Creates a new Resource.

        The created ressource type depends on the used URI.

        :param uri: the resource URI
        :type uri: URI
        :return: a new Resource
        :rtype: Resource

        .. seealso:: URI, Resource, XMIResource
        """
        ...

    def remove_resource(self, resource): # -> None:
        ...

    def get_resource(self, uri, options=...):
        ...

    def can_resolve(self, uri_path, from_resource=...): # -> bool:
        ...

    def resolve(self, uri, from_resource=...): # -> Any | None:
        ...



class URI:
    _uri_norm = ...
    _uri_split = ...
    def __init__(self, uri) -> None:
        ...

    @property
    def protocol(self): # -> None:
        ...

    @property
    def extension(self): # -> None:
        ...

    @property
    def segments(self):
        ...

    @property
    def last_segment(self):
        ...

    def create_instream(self): # -> BufferedReader:
        ...

    def close_stream(self): # -> None:
        ...

    def create_outstream(self): # -> BufferedWriter:
        ...

    def normalize(self):
        ...

    def relative_from_me(self, other_uri):
        ...

    def apply_relative_from_me(self, relative_path):
        ...



class HttpURI(URI):
    def __init__(self, uri) -> None:
        ...

    def create_instream(self): # -> _UrlopenRet:
        ...

    def create_outstream(self):
        ...

    def apply_relative_from_me(self, relative_path):
        ...



class MetamodelDecoder:
    @staticmethod
    def split_path(path): # -> tuple[Any | None, Any]:
        ...

    @staticmethod
    def can_resolve(path, registry): # -> bool:
        ...

    @staticmethod
    def resolve(path, registry): # -> Any | None:
        ...



class Global_URI_decoder:
    @staticmethod
    def can_resolve(path, from_resource=...): # -> bool:
        ...

    @staticmethod
    def resolve(path, from_resource=...): # -> Any | None:
        ...



class URIMapper:
    @staticmethod
    def translate(path, from_resource=...):
        ...



class URIConverter:
    @classmethod
    def convert(cls, uri, resource_set=...):
        ...



class AbstractURIConverter:
    @staticmethod
    @abstractmethod
    def can_handle(uri):
        ...

    @staticmethod
    @abstractmethod
    def convert(uri):
        ...



class HttpURIConverter(AbstractURIConverter):
    @staticmethod
    def can_handle(uri):
        ...

    @staticmethod
    def convert(uri): # -> HttpURI:
        ...



class LocalMetamodelDecoder:
    @staticmethod
    def can_resolve(path, from_resource=...): # -> bool:
        ...

    @staticmethod
    def resolve(path, from_resource=...): # -> Any | None:
        ...



class Resource:
    decoders = ...
    def __init__(self, uri=..., use_uuid=...) -> None:
        ...

    @property
    def uri(self): # -> None:
        ...

    @uri.setter
    def uri(self, value): # -> None:
        ...

    def resolve(self, fragment, resource=...): # -> Any | None:
        ...

    def resolve_object(self, path): # -> Any | None:
        ...

    @staticmethod
    def extract_rootnum_and_frag(fragment): # -> tuple[int, Any] | tuple[Literal[0], Any]:
        ...

    def prefix2epackage(self, prefix): # -> KeyError:
        ...

    def get_metamodel(self, nsuri):
        ...

    @staticmethod
    def normalize(fragment):
        ...

    @staticmethod
    def is_fragment_uuid(fragment):
        ...

    @staticmethod
    def get_id_attribute(eclass): # -> None:
        ...

    def append(self, root): # -> None:
        ...

    def remove(self, root): # -> None:
        ...

    def open_out_stream(self, other=...): # -> BufferedWriter:
        ...

    def extend(self, values): # -> None:
        ...
