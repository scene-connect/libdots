"""
This type stub file was generated by pyright.
"""

from typing import Any
from typing import Generator

from requests.adapters import HTTPAdapter

from .resultset import ResultSet

"""Python client for InfluxDB."""

class InfluxDBClient:
    """InfluxDBClient primary client object to connect InfluxDB.

    The :class:`~.InfluxDBClient` object holds information necessary to
    connect to InfluxDB. Requests can be made to InfluxDB directly through
    the client.

    The client supports the use as a `context manager
    <https://docs.python.org/3/reference/datamodel.html#context-managers>`_.

    :param host: hostname to connect to InfluxDB, defaults to 'localhost'
    :type host: str
    :param port: port to connect to InfluxDB, defaults to 8086
    :type port: int
    :param username: user to connect, defaults to 'root'
    :type username: str
    :param password: password of the user, defaults to 'root'
    :type password: str
    :param pool_size: urllib3 connection pool size, defaults to 10.
    :type pool_size: int
    :param database: database name to connect to, defaults to None
    :type database: str
    :param ssl: use https instead of http to connect to InfluxDB, defaults to
        False
    :type ssl: bool
    :param verify_ssl: verify SSL certificates for HTTPS requests, defaults to
        False
    :type verify_ssl: bool
    :param timeout: number of seconds Requests will wait for your client to
        establish a connection, defaults to None
    :type timeout: int
    :param retries: number of attempts your client will make before aborting,
        defaults to 3
        0 - try until success
        1 - attempt only once (without retry)
        2 - maximum two attempts (including one retry)
        3 - maximum three attempts (default option)
    :type retries: int
    :param use_udp: use UDP to connect to InfluxDB, defaults to False
    :type use_udp: bool
    :param udp_port: UDP port to connect to InfluxDB, defaults to 4444
    :type udp_port: int
    :param proxies: HTTP(S) proxy to use for Requests, defaults to {}
    :type proxies: dict
    :param path: path of InfluxDB on the server to connect, defaults to ''
    :type path: str
    :param cert: Path to client certificate information to use for mutual TLS
        authentication. You can specify a local cert to use
        as a single file containing the private key and the certificate, or as
        a tuple of both filesâ€™ paths, defaults to None
    :type cert: str
    :param gzip: use gzip content encoding to compress requests
    :type gzip: bool
    :param session: allow for the new client request to use an existing
        requests Session, defaults to None
    :type session: requests.Session
    :param headers: headers to add to Requests, will add 'Content-Type'
        and 'Accept' unless these are already present, defaults to {}
    :type headers: dict
    :param socket_options: use custom tcp socket options,
        If not specified, then defaults are loaded from
        ``HTTPConnection.default_socket_options``
    :type socket_options: list

    :raises ValueError: if cert is provided but ssl is disabled (set to False)
    """

    def __init__(
        self,
        host=...,
        port=...,
        username=...,
        password=...,
        database=...,
        ssl=...,
        verify_ssl=...,
        timeout=...,
        retries=...,
        use_udp=...,
        udp_port=...,
        proxies=...,
        pool_size=...,
        path=...,
        cert=...,
        gzip=...,
        session=...,
        headers=...,
        socket_options=...,
    ) -> None:
        """Construct a new InfluxDBClient object."""
        ...

    def __enter__(self):  # -> Self:
        """Enter function as used by context manager."""
        ...

    def __exit__(self, _exc_type, _exc_value, _traceback):  # -> None:
        """Exit function as used by context manager."""
        ...

    @classmethod
    def from_dsn(cls, dsn, **kwargs):  # -> Self:
        r"""Generate an instance of InfluxDBClient from given data source name.

        Return an instance of :class:`~.InfluxDBClient` from the provided
        data source name. Supported schemes are "influxdb", "https+influxdb"
        and "udp+influxdb". Parameters for the :class:`~.InfluxDBClient`
        constructor may also be passed to this method.

        :param dsn: data source name
        :type dsn: string
        :param kwargs: additional parameters for `InfluxDBClient`
        :type kwargs: dict
        :raises ValueError: if the provided DSN has any unexpected values

        :Example:

        ::

            >> cli = InfluxDBClient.from_dsn('influxdb://username:password@\
            localhost:8086/databasename', timeout=5)
            >> type(cli)
            <class 'influxdb.client.InfluxDBClient'>
            >> cli = InfluxDBClient.from_dsn('udp+influxdb://username:pass@\
            localhost:8086/databasename', timeout=5, udp_port=159)
            >> print('{0._baseurl} - {0.use_udp} {0.udp_port}'.format(cli))
            http://localhost:8086 - True 159

        .. note:: parameters provided in `**kwargs` may override dsn parameters
        .. note:: when using "udp+influxdb" the specified port (if any) will
            be used for the TCP connection; specify the UDP port with the
            additional `udp_port` parameter (cf. examples).
        """
        ...

    def switch_database(self, database):  # -> None:
        """Change the client's database.

        :param database: the name of the database to switch to
        :type database: str
        """
        ...

    def switch_user(self, username, password):  # -> None:
        """Change the client's username.

        :param username: the username to switch to
        :type username: str
        :param password: the password for the username
        :type password: str
        """
        ...

    def request(
        self,
        url,
        method=...,
        params=...,
        data=...,
        stream=...,
        expected_response_code=...,
        headers=...,
    ):  # -> Response:
        """Make a HTTP request to the InfluxDB API.

        :param url: the path of the HTTP request, e.g. write, query, etc.
        :type url: str
        :param method: the HTTP method for the request, defaults to GET
        :type method: str
        :param params: additional parameters for the request, defaults to None
        :type params: dict
        :param data: the data of the request, defaults to None
        :type data: str
        :param stream: True if a query uses chunked responses
        :type stream: bool
        :param expected_response_code: the expected response code of
            the request, defaults to 200
        :type expected_response_code: int
        :param headers: headers to add to the request
        :type headers: dict
        :returns: the response from the request
        :rtype: :class:`requests.Response`
        :raises InfluxDBServerError: if the response code is any server error
            code (5xx)
        :raises InfluxDBClientError: if the response code is not the
            same as `expected_response_code` and is not a server error code
        """
        ...

    def write(
        self, data, params=..., expected_response_code=..., protocol=...
    ):  # -> Literal[True]:
        """Write data to InfluxDB.

        :param data: the data to be written
        :type data: (if protocol is 'json') dict
                    (if protocol is 'line') sequence of line protocol strings
                                            or single string
        :param params: additional parameters for the request, defaults to None
        :type params: dict
        :param expected_response_code: the expected response code of the write
            operation, defaults to 204
        :type expected_response_code: int
        :param protocol: protocol of input data, either 'json' or 'line'
        :type protocol: str
        :returns: True, if the write operation is successful
        :rtype: bool
        """
        ...

    def query(
        self,
        query: str,
        params: dict[str, Any] = ...,
        bind_params: dict[str, Any] = ...,
        epoch: str = ...,
        expected_response_code: int = ...,
        database: str = ...,
        raise_errors: bool = ...,
        chunked: bool = ...,
        chunk_size: int = ...,
        method: str = ...,
    ) -> Generator[ResultSet, Any, None] | ResultSet | list[ResultSet]:
        """Send a query to InfluxDB.

        .. danger::
            In order to avoid injection vulnerabilities (similar to `SQL
            injection <https://www.owasp.org/index.php/SQL_Injection>`_
            vulnerabilities), do not directly include untrusted data into the
            ``query`` parameter, use ``bind_params`` instead.

        :param query: the actual query string
        :type query: str

        :param params: additional parameters for the request,
            defaults to {}
        :type params: dict

        :param bind_params: bind parameters for the query:
            any variable in the query written as ``'$var_name'`` will be
            replaced with ``bind_params['var_name']``. Only works in the
            ``WHERE`` clause and takes precedence over ``params['params']``
        :type bind_params: dict

        :param epoch: response timestamps to be in epoch format either 'h',
            'm', 's', 'ms', 'u', or 'ns',defaults to `None` which is
            RFC3339 UTC format with nanosecond precision
        :type epoch: str

        :param expected_response_code: the expected status code of response,
            defaults to 200
        :type expected_response_code: int

        :param database: database to query, defaults to None
        :type database: str

        :param raise_errors: Whether or not to raise exceptions when InfluxDB
            returns errors, defaults to True
        :type raise_errors: bool

        :param chunked: Enable to use chunked responses from InfluxDB.
            With ``chunked`` enabled, one ResultSet is returned per chunk
            containing all results within that chunk
        :type chunked: bool

        :param chunk_size: Size of each chunk to tell InfluxDB to use.
        :type chunk_size: int

        :param method: the HTTP method for the request, defaults to GET
        :type method: str

        :returns: the queried data
        :rtype: :class:`~.ResultSet`
        """
        ...

    def write_points(
        self,
        points: list[dict[str, Any]],
        time_precision: str = ...,
        database: str = ...,
        retention_policy: str = ...,
        tags: dict[str, Any] = ...,
        batch_size: int = ...,
        protocol: str = ...,
        consistency: str = ...,
    ) -> bool:
        """Write to multiple time series names.

        :param points: the list of points to be written in the database
        :type points: list of dictionaries, each dictionary represents a point
        :type points: (if protocol is 'json') list of dicts, where each dict
                                            represents a point.
                    (if protocol is 'line') sequence of line protocol strings.
        :param time_precision: Either 's', 'm', 'ms' or 'u', defaults to None
        :type time_precision: str
        :param database: the database to write the points to. Defaults to
            the client's current database
        :type database: str
        :param tags: a set of key-value pairs associated with each point. Both
            keys and values must be strings. These are shared tags and will be
            merged with point-specific tags, defaults to None
        :type tags: dict
        :param retention_policy: the retention policy for the points. Defaults
            to None
        :type retention_policy: str
        :param batch_size: value to write the points in batches
            instead of all at one time. Useful for when doing data dumps from
            one database to another or when doing a massive write operation,
            defaults to None
        :type batch_size: int
        :param protocol: Protocol for writing data. Either 'line' or 'json'.
        :type protocol: str
        :param consistency: Consistency for the points.
            One of {'any','one','quorum','all'}.
        :type consistency: str
        :returns: True, if the operation is successful
        :rtype: bool

        .. note:: if no retention policy is specified, the default retention
            policy for the database is used
        """
        ...

    def ping(self) -> str:
        """Check connectivity to InfluxDB.

        :returns: The version of the InfluxDB the client is connected to
        """
        ...

    def get_list_database(self) -> list[dict[str, Any]]:
        """Get the list of databases in InfluxDB.

        :returns: all databases in InfluxDB
        :rtype: list of dictionaries

        :Example:

        ::

            >> dbs = client.get_list_database()
            >> dbs
            [{u'name': u'db1'}, {u'name': u'db2'}, {u'name': u'db3'}]
        """
        ...

    def get_list_series(self, database=..., measurement=..., tags=...):  # -> list[Any]:
        """
        Query SHOW SERIES returns the distinct series in your database.

        FROM and WHERE clauses are optional.

        :param measurement: Show all series from a measurement
        :type id: string
        :param tags: Show all series that match given tags
        :type id: dict
        :param database: the database from which the series should be
            shows, defaults to client's current database
        :type database: str
        """
        ...

    def create_database(self, dbname: str) -> None:
        """Create a new database in InfluxDB.

        :param dbname: the name of the database to create
        :type dbname: str
        """
        ...

    def drop_database(self, dbname) -> None:
        """Drop a database from InfluxDB.

        :param dbname: the name of the database to drop
        :type dbname: str
        """
        ...

    def get_list_measurements(self):  # -> list[dict[Any, Any]]:
        """Get the list of measurements in InfluxDB.

        :returns: all measurements in InfluxDB
        :rtype: list of dictionaries

        :Example:

        ::

            >> dbs = client.get_list_measurements()
            >> dbs
            [{u'name': u'measurements1'},
             {u'name': u'measurements2'},
             {u'name': u'measurements3'}]
        """
        ...

    def drop_measurement(self, measurement):  # -> None:
        """Drop a measurement from InfluxDB.

        :param measurement: the name of the measurement to drop
        :type measurement: str
        """
        ...

    def create_retention_policy(
        self, name, duration, replication, database=..., default=..., shard_duration=...
    ):  # -> None:
        """Create a retention policy for a database.

        :param name: the name of the new retention policy
        :type name: str
        :param duration: the duration of the new retention policy.
            Durations such as 1h, 90m, 12h, 7d, and 4w, are all supported
            and mean 1 hour, 90 minutes, 12 hours, 7 day, and 4 weeks,
            respectively. For infinite retention - meaning the data will
            never be deleted - use 'INF' for duration.
            The minimum retention period is 1 hour.
        :type duration: str
        :param replication: the replication of the retention policy
        :type replication: str
        :param database: the database for which the retention policy is
            created. Defaults to current client's database
        :type database: str
        :param default: whether or not to set the policy as default
        :type default: bool
        :param shard_duration: the shard duration of the retention policy.
            Durations such as 1h, 90m, 12h, 7d, and 4w, are all supported and
            mean 1 hour, 90 minutes, 12 hours, 7 day, and 4 weeks,
            respectively. Infinite retention is not supported. As a workaround,
            specify a "1000w" duration to achieve an extremely long shard group
            duration. Defaults to "0s", which is interpreted by the database
            to mean the default value given the duration.
            The minimum shard group duration is 1 hour.
        :type shard_duration: str
        """
        ...

    def alter_retention_policy(
        self,
        name,
        database=...,
        duration=...,
        replication=...,
        default=...,
        shard_duration=...,
    ):  # -> None:
        """Modify an existing retention policy for a database.

        :param name: the name of the retention policy to modify
        :type name: str
        :param database: the database for which the retention policy is
            modified. Defaults to current client's database
        :type database: str
        :param duration: the new duration of the existing retention policy.
            Durations such as 1h, 90m, 12h, 7d, and 4w, are all supported
            and mean 1 hour, 90 minutes, 12 hours, 7 day, and 4 weeks,
            respectively. For infinite retention, meaning the data will
            never be deleted, use 'INF' for duration.
            The minimum retention period is 1 hour.
        :type duration: str
        :param replication: the new replication of the existing
            retention policy
        :type replication: int
        :param default: whether or not to set the modified policy as default
        :type default: bool
        :param shard_duration: the shard duration of the retention policy.
            Durations such as 1h, 90m, 12h, 7d, and 4w, are all supported and
            mean 1 hour, 90 minutes, 12 hours, 7 day, and 4 weeks,
            respectively. Infinite retention is not supported. As a workaround,
            specify a "1000w" duration to achieve an extremely long shard group
            duration.
            The minimum shard group duration is 1 hour.
        :type shard_duration: str

        .. note:: at least one of duration, replication, or default flag
            should be set. Otherwise the operation will fail.
        """
        ...

    def drop_retention_policy(self, name, database=...):  # -> None:
        """Drop an existing retention policy for a database.

        :param name: the name of the retention policy to drop
        :type name: str
        :param database: the database for which the retention policy is
            dropped. Defaults to current client's database
        :type database: str
        """
        ...

    def get_list_retention_policies(self, database=...):  # -> list[dict[Any, Any]]:
        """Get the list of retention policies for a database.

        :param database: the name of the database, defaults to the client's
            current database
        :type database: str
        :returns: all retention policies for the database
        :rtype: list of dictionaries

        :Example:

        ::

            >> ret_policies = client.get_list_retention_policies('my_db')
            >> ret_policies
            [{u'default': True,
              u'duration': u'0',
              u'name': u'default',
              u'replicaN': 1}]
        """
        ...

    def get_list_users(self):  # -> list[dict[Any, Any]]:
        """Get the list of all users in InfluxDB.

        :returns: all users in InfluxDB
        :rtype: list of dictionaries

        :Example:

        ::

            >> users = client.get_list_users()
            >> users
            [{u'admin': True, u'user': u'user1'},
             {u'admin': False, u'user': u'user2'},
             {u'admin': False, u'user': u'user3'}]
        """
        ...

    def create_user(self, username, password, admin=...):  # -> None:
        """Create a new user in InfluxDB.

        :param username: the new username to create
        :type username: str
        :param password: the password for the new user
        :type password: str
        :param admin: whether the user should have cluster administration
            privileges or not
        :type admin: boolean
        """
        ...

    def drop_user(self, username):  # -> None:
        """Drop a user from InfluxDB.

        :param username: the username to drop
        :type username: str
        """
        ...

    def set_user_password(self, username, password):  # -> None:
        """Change the password of an existing user.

        :param username: the username who's password is being changed
        :type username: str
        :param password: the new password for the user
        :type password: str
        """
        ...

    def delete_series(self, database=..., measurement=..., tags=...):  # -> None:
        """Delete series from a database.

        Series must be filtered by either measurement and tags.
        This method cannot be used to delete all series, use
        `drop_database` instead.

        :param database: the database from which the series should be
            deleted, defaults to client's current database
        :type database: str
        :param measurement: Delete all series from a measurement
        :type measurement: str
        :param tags: Delete all series that match given tags
        :type tags: dict
        """
        ...

    def grant_admin_privileges(self, username):  # -> None:
        """Grant cluster administration privileges to a user.

        :param username: the username to grant privileges to
        :type username: str

        .. note:: Only a cluster administrator can create/drop databases
            and manage users.
        """
        ...

    def revoke_admin_privileges(self, username):  # -> None:
        """Revoke cluster administration privileges from a user.

        :param username: the username to revoke privileges from
        :type username: str

        .. note:: Only a cluster administrator can create/ drop databases
            and manage users.
        """
        ...

    def grant_privilege(self, privilege, database, username):  # -> None:
        """Grant a privilege on a database to a user.

        :param privilege: the privilege to grant, one of 'read', 'write'
            or 'all'. The string is case-insensitive
        :type privilege: str
        :param database: the database to grant the privilege on
        :type database: str
        :param username: the username to grant the privilege to
        :type username: str
        """
        ...

    def revoke_privilege(self, privilege, database, username):  # -> None:
        """Revoke a privilege on a database from a user.

        :param privilege: the privilege to revoke, one of 'read', 'write'
            or 'all'. The string is case-insensitive
        :type privilege: str
        :param database: the database to revoke the privilege on
        :type database: str
        :param username: the username to revoke the privilege from
        :type username: str
        """
        ...

    def get_list_privileges(self, username):  # -> list[dict[Any, Any]]:
        """Get the list of all privileges granted to given user.

        :param username: the username to get privileges of
        :type username: str

        :returns: all privileges granted to given user
        :rtype: list of dictionaries

        :Example:

        ::

            >> privileges = client.get_list_privileges('user1')
            >> privileges
            [{u'privilege': u'WRITE', u'database': u'db1'},
             {u'privilege': u'ALL PRIVILEGES', u'database': u'db2'},
             {u'privilege': u'NO PRIVILEGES', u'database': u'db3'}]
        """
        ...

    def get_list_continuous_queries(self):  # -> list[dict[Any, list[Any]]]:
        """Get the list of continuous queries in InfluxDB.

        :return: all CQs in InfluxDB
        :rtype: list of dictionaries

        :Example:

        ::

            >> cqs = client.get_list_cqs()
            >> cqs
            [
                {
                    u'db1': []
                },
                {
                    u'db2': [
                        {
                            u'name': u'vampire',
                            u'query': u'CREATE CONTINUOUS QUERY vampire ON '
                                       'mydb BEGIN SELECT count(dracula) INTO '
                                       'mydb.autogen.all_of_them FROM '
                                       'mydb.autogen.one GROUP BY time(5m) END'
                        }
                    ]
                }
            ]
        """
        ...

    def create_continuous_query(
        self, name, select, database=..., resample_opts=...
    ):  # -> None:
        r"""Create a continuous query for a database.

        :param name: the name of continuous query to create
        :type name: str
        :param select: select statement for the continuous query
        :type select: str
        :param database: the database for which the continuous query is
            created. Defaults to current client's database
        :type database: str
        :param resample_opts: resample options
        :type resample_opts: str

        :Example:

        ::

            >> select_clause = 'SELECT mean("value") INTO "cpu_mean" ' \
            ...                 'FROM "cpu" GROUP BY time(1m)'
            >> client.create_continuous_query(
            ...     'cpu_mean', select_clause, 'db_name', 'EVERY 10s FOR 2m'
            ... )
            >> client.get_list_continuous_queries()
            [
                {
                    'db_name': [
                        {
                            'name': 'cpu_mean',
                            'query': 'CREATE CONTINUOUS QUERY "cpu_mean" '
                                    'ON "db_name" '
                                    'RESAMPLE EVERY 10s FOR 2m '
                                    'BEGIN SELECT mean("value") '
                                    'INTO "cpu_mean" FROM "cpu" '
                                    'GROUP BY time(1m) END'
                        }
                    ]
                }
            ]
        """
        ...

    def drop_continuous_query(self, name, database=...):  # -> None:
        """Drop an existing continuous query for a database.

        :param name: the name of continuous query to drop
        :type name: str
        :param database: the database for which the continuous query is
            dropped. Defaults to current client's database
        :type database: str
        """
        ...

    def send_packet(self, packet, protocol=..., time_precision=...):  # -> None:
        """Send an UDP packet.

        :param packet: the packet to be sent
        :type packet: (if protocol is 'json') dict
                      (if protocol is 'line') list of line protocol strings
        :param protocol: protocol of input data, either 'json' or 'line'
        :type protocol: str
        :param time_precision: Either 's', 'm', 'ms' or 'u', defaults to None
        :type time_precision: str
        """
        ...

    def close(self) -> None:
        """Close http session."""
        ...

class _SocketOptionsAdapter(HTTPAdapter):
    """_SocketOptionsAdapter injects socket_options into HTTP Adapter."""

    def __init__(self, *args, **kwargs) -> None: ...
    def init_poolmanager(self, *args, **kwargs):  # -> None:
        ...
